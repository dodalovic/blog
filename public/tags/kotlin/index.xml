<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kotlin on Dusan Odalovic</title>
    <link>https://dodalovic.github.io/tags/kotlin/</link>
    <description>Recent content in kotlin on Dusan Odalovic</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 30 Jul 2017 13:35:00 +0100</lastBuildDate>
    
	<atom:link href="https://dodalovic.github.io/tags/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Zero boilerplate implementing state pattern in kotlin</title>
      <link>https://dodalovic.github.io/posts/2017/07/zero-boilerplate-implementing-state-pattern-in-kotlin/</link>
      <pubDate>Sun, 30 Jul 2017 13:35:00 +0100</pubDate>
      
      <guid>https://dodalovic.github.io/posts/2017/07/zero-boilerplate-implementing-state-pattern-in-kotlin/</guid>
      <description>State pattern is a pretty nice solution for solving problems related to changing behavior of some component(class) at runtime, which varies depending on current state of that object. Clients of our class having dynamic behavior have an impression that, upon interaction with that class, it seems like thereâ€™s different implementation of that object as of that interaction. Thereâ€™s no magic involved â€“ weâ€™re just using composition, and our dynamic object just delegates call to State object it encapsulates.</description>
    </item>
    
    <item>
      <title>Decorator pattern in kotlin</title>
      <link>https://dodalovic.github.io/posts/2017/07/decorator-pattern-in-kotlin/</link>
      <pubDate>Sun, 23 Jul 2017 13:35:00 +0100</pubDate>
      
      <guid>https://dodalovic.github.io/posts/2017/07/decorator-pattern-in-kotlin/</guid>
      <description>If you feel curious how would an implementation of decorator design pattern look like in Kotlin, this might be the right place for you. This example is just a very basic thing that you then tweak until itâ€™s perfect. Pattern definition can be found at Wiki, but whatâ€™s important is that you can compose chain of decorators at runtime and in such a way â€“ you can control runtime behavior of your system.</description>
    </item>
    
    <item>
      <title>Constructors in kotlin</title>
      <link>https://dodalovic.github.io/posts/2017/06/constructors-in-kotlin/</link>
      <pubDate>Sun, 25 Jun 2017 13:35:00 +0100</pubDate>
      
      <guid>https://dodalovic.github.io/posts/2017/06/constructors-in-kotlin/</guid>
      <description>Constructors in general Constructors are regular functions that give a chance to developer to initialise state of class instance. They are completely optional, and it&amp;rsquo;s perfectly valid to have this, although not so useful ðŸ˜ƒ:
1  class Person   Constructors in Kotlin behave very similar to the ones we have in Java. We have two types of constructors in Kotlin:
 Primary Secondary  Primary constructors Primary constructors give us a chance to initialise state of our instance with very clean syntax.</description>
    </item>
    
  </channel>
</rss>